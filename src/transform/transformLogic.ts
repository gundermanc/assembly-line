//import { Transform } from "assemblyscript/dist/asc";
import { Module, Program, Statement, NodeKind, ExpressionStatement, ExpressionId } from "assemblyscript/dist/assemblyscript";
import { CallExpression, Expression, Node, StringLiteralExpression } from "types:assemblyscript/src/ast";
import * as fs from 'fs';

// HACK: Not sure why, extending Transform breaks runtime resolution.
export class TransformLogic /* extends Transform*/ {
    private readonly outFileName: string;
    private readonly fileDescriptor: number;
    private readonly backend: CSharpBackend;

    constructor(outFileName: string) {
        this.outFileName = outFileName;
        this.fileDescriptor = fs.openSync(this.outFileName, 'w');

        // TODO: should be passed in as an argument.
        this.backend = new CSharpBackend();
    }

    afterInitialize?(program: Program): void | Promise<void> {
        for (const source of program.sources) {

            // TODO: For now compile just our test sample.
            if (source.simplePath.endsWith('foo')) {

                this.write(this.backend.getFileStart(source.simplePath));

                for (const statement of source.statements) {
                    this.processStatement(statement);
                }

                this.write(this.backend.getFileEnd());
            }
        }
    }

    processStatement(statement: Statement): void {
        this.dumpNode(statement);

        switch (statement.kind) {
            case NodeKind.Import:
                // TODO
                break;

            case NodeKind.Variable:
                // TODO
                break;

            case NodeKind.Call:
                console.log("Call!");
                break;

            case NodeKind.Expression:
                this.transpileExpressionStatement(statement as ExpressionStatement);
                break;

            default:
                console.log('Unsupported statement kind: ' + statement.kind);
                //throw new Error('Unsupported statement kind: ' + statement.kind);
        }

        this.write(';');
        this.write(this.backend.getLineEnding());
    }

    transpileExpressionStatement(expressionStatement: ExpressionStatement): void {
        this.transpileExpression(expressionStatement.expression);
    }

    transpileExpression(expression: Expression): void {
        switch (expression.kind) {
            case NodeKind.Call:
                console.log("It's a call!");
                this.transpileCallExpression(expression as CallExpression);
                break;
            default:
                console.log("Unknown expression kind: " + expression.kind);
        }
    }

    transpileCallExpression(expression: CallExpression): void {

        // TODO: expression.expression is the expression for the calling thing (e.g.: console.log).
        // For now, hard code, but this should delegate to some sort of symbol resolver or symbol table
        // in the future.
        const firstArg = expression.args[0];

        // TODO: expressions should be parsed recursively and converted to the equivalent
        // expression in the target language.
        const asString = (firstArg as StringLiteralExpression);

        this.write(`System.Text.Console.WriteLine("${asString.value}")`)
    }

    dumpNode(statement: Statement): void {
        console.log(`Node kind ${statement.kind} at (${statement.range.start}, ${statement.range.end}`);
    }

    write(line: string): void {
        fs.writeFileSync(this.fileDescriptor, line);
    }
}

export abstract class Backend {

    getLineEnding(): string {
        return '\r\n';
    }

    public abstract getFileStart(className: string): string;

    public abstract getFileEnd(): string;
}

export class CSharpBackend extends Backend {

    public getFileStart(className: string): string {
        return `// Generated by assembly-line.
public static class Program
{
    public static void Main(string[] args)
    {
`;
    }

    public getFileEnd(): string {
        return `    }
}`;
    }
}
